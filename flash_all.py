#!/usr/bin/env python3
"""
WiFi Walkie-Talkie - Auto Flash All Devices

Detects connected M5Stack Atom Echo devices by MAC address,
configures each with the correct name, and flashes firmware.

Usage:
    python flash_all.py           # Flash all connected devices
    python flash_all.py --list    # Just list connected devices
"""

import os
import sys
import subprocess
import serial.tools.list_ports
import re
from pathlib import Path

# Device MAC address to name mapping
DEVICE_MAP = {
    "90:15:06:fd:5b:c4": "Spottens",
    "f4:65:0b:08:4b:88": "Larsens",
    "f4:65:0b:08:4d:f4": "McKameys",
}

# Paths - use venv in project directory
SCRIPT_DIR = Path(__file__).parent
ENV_FILE = SCRIPT_DIR / ".env"
CONFIG_LOCAL = SCRIPT_DIR / "include" / "config_local.h"
VENV_SCRIPTS = SCRIPT_DIR / "venv" / "Scripts"
PYTHON = VENV_SCRIPTS / "python.exe"
PIO = VENV_SCRIPTS / "pio.exe"


def find_esp32_ports():
    """Find all COM ports with ESP32 devices."""
    ports = []
    for port in serial.tools.list_ports.comports():
        # Look for Silicon Labs CP210x or ESP32 USB
        if "CP210" in (port.description or "") or "USB" in (port.description or ""):
            ports.append(port.device)
        # Also check by VID/PID for common ESP32 USB chips
        if port.vid == 0x10C4 or port.vid == 0x1A86:  # CP210x or CH340
            if port.device not in ports:
                ports.append(port.device)
    return sorted(ports)


def get_mac_address(port):
    """Read MAC address from ESP32 using esptool."""
    try:
        result = subprocess.run(
            [str(PYTHON), "-m", "esptool", "--port", port, "read_mac"],
            capture_output=True,
            text=True,
            timeout=15
        )

        # Parse MAC from output like "MAC: aa:bb:cc:dd:ee:ff"
        match = re.search(r"MAC:\s*([0-9a-fA-F:]{17})", result.stdout)
        if match:
            return match.group(1).lower()

        # Also try stderr (esptool sometimes outputs there)
        match = re.search(r"MAC:\s*([0-9a-fA-F:]{17})", result.stderr)
        if match:
            return match.group(1).lower()

    except subprocess.TimeoutExpired:
        print(f"  Timeout reading MAC from {port}")
    except Exception as e:
        print(f"  Error reading MAC from {port}: {e}")

    return None


def read_env_config():
    """Read base configuration from .env file."""
    config = {}
    if ENV_FILE.exists():
        with open(ENV_FILE, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                if '=' in line:
                    key, value = line.split('=', 1)
                    config[key.strip()] = value.strip()
    return config


def generate_config_header(config, device_name):
    """Generate config_local.h with the specified device name."""
    CONFIG_LOCAL.parent.mkdir(exist_ok=True)

    with open(CONFIG_LOCAL, 'w') as f:
        f.write("// Auto-generated configuration file\n")
        f.write(f"// Device: {device_name}\n")
        f.write("// DO NOT EDIT - Generated by flash_all.py\n\n")
        f.write("#ifndef CONFIG_LOCAL_H\n")
        f.write("#define CONFIG_LOCAL_H\n\n")

        # WiFi networks
        for i in range(1, 4):
            ssid = config.get(f"WIFI_SSID_{i}", "")
            password = config.get(f"WIFI_PASSWORD_{i}", "")
            if ssid and password:
                f.write(f'#define WIFI_SSID_{i} "{ssid}"\n')
                f.write(f'#define WIFI_PASSWORD_{i} "{password}"\n\n')

        # WebSocket server
        server = config.get("WEBSOCKET_SERVER", "")
        if server:
            f.write(f'#define WEBSOCKET_SERVER "{server}"\n')
            # Extract port from URL if present (e.g., ws://host:8280)
            port_match = re.search(r':(\d+)', server.replace('ws://', '').replace('wss://', ''))
            if port_match:
                port = port_match.group(1)
                f.write(f'#define WEBSOCKET_PORT {port}\n')

        # Device name
        f.write(f'#define DEVICE_NAME "{device_name}"\n')

        f.write("\n#endif // CONFIG_LOCAL_H\n")


def flash_device(port, device_name):
    """Build and flash firmware to device with real-time output."""
    print(f"\n  Building and flashing {device_name}...\n", flush=True)

    try:
        # Use Popen for real-time output streaming
        process = subprocess.Popen(
            [str(PIO), "run", "--target", "upload", "--upload-port", port],
            cwd=SCRIPT_DIR,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1  # Line buffered
        )

        # Stream output in real-time
        for line in process.stdout:
            line = line.rstrip()
            # Filter to show important lines only
            if any(x in line for x in ['Compiling', 'Linking', 'Building', 'Uploading',
                                         'SUCCESS', 'FAILED', 'error:', 'Error',
                                         'Writing', 'Leaving', '%']):
                print(f"    {line}", flush=True)
            elif line.startswith('['):
                print(f"    {line}", flush=True)

        process.wait(timeout=180)

        if process.returncode == 0:
            print(f"\n  [OK] Successfully flashed {device_name}")
            return True
        else:
            print(f"\n  [FAIL] Failed to flash {device_name}")
            return False

    except subprocess.TimeoutExpired:
        process.kill()
        print(f"\n  [FAIL] Timeout flashing {device_name}")
        return False
    except Exception as e:
        print(f"\n  [FAIL] Error flashing {device_name}: {e}")
        return False


def main():
    print("=" * 60)
    print("WiFi Walkie-Talkie - Auto Flash")
    print("=" * 60)

    # Check for --list flag
    list_only = "--list" in sys.argv

    # Find all ESP32 ports
    print("\nScanning for ESP32 devices...")
    ports = find_esp32_ports()

    if not ports:
        print("No ESP32 devices found!")
        print("Make sure devices are connected via USB.")
        sys.exit(1)

    print(f"Found {len(ports)} potential device(s): {', '.join(ports)}")

    # Read MAC addresses and identify devices
    devices = []
    print("\nIdentifying devices by MAC address...")

    for port in ports:
        print(f"\n{port}:")
        mac = get_mac_address(port)

        if mac:
            device_name = DEVICE_MAP.get(mac, None)
            if device_name:
                print(f"  MAC: {mac}")
                print(f"  Device: {device_name} [OK]")
                devices.append((port, mac, device_name))
            else:
                print(f"  MAC: {mac}")
                print(f"  Device: UNKNOWN (not in device map)")
        else:
            print(f"  Could not read MAC address")

    if not devices:
        print("\nNo known devices found!")
        print("Known MAC addresses:")
        for mac, name in DEVICE_MAP.items():
            print(f"  {mac} = {name}")
        sys.exit(1)

    print(f"\n{'=' * 60}")
    print(f"Found {len(devices)} known device(s):")
    for port, mac, name in devices:
        print(f"  {name:12} on {port} ({mac})")
    print("=" * 60)

    if list_only:
        print("\n(--list mode, not flashing)")
        sys.exit(0)

    # Read base config
    config = read_env_config()
    if not config:
        print("\nError: Could not read .env file!")
        sys.exit(1)

    # Flash each device
    print("\nFlashing devices...")
    success = 0
    failed = 0

    for port, mac, device_name in devices:
        print(f"\n{'-' * 40}", flush=True)
        print(f"Configuring {device_name}...", flush=True)

        # Generate config with this device's name
        generate_config_header(config, device_name)
        print(f"  Generated config_local.h", flush=True)

        # Flash
        if flash_device(port, device_name):
            success += 1
        else:
            failed += 1

    # Summary
    print(f"\n{'=' * 60}")
    print("SUMMARY")
    print("=" * 60)
    print(f"  Successful: {success}")
    print(f"  Failed:     {failed}")

    if failed == 0:
        print("\n[OK] All devices flashed successfully!")
    else:
        print(f"\n[FAIL] {failed} device(s) failed to flash")
        sys.exit(1)


if __name__ == "__main__":
    # Set UTF-8 encoding for Windows
    os.environ["PYTHONIOENCODING"] = "utf-8"

    try:
        main()
    except KeyboardInterrupt:
        print("\n\nCancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\nError: {e}")
        sys.exit(1)
